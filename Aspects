class Aspects
  def self.on(*args,&closure)

    aspectables = encontrarAspectables(*args)

    throw(ArgumentError,"Origen Vacio") if aspectables.size==0

    aplicarAspectos(aspectables,&closure)

  end

  def self.encontrarAspectables(*parametros)
    parametros.grep(Regexp).map(&:toAspectable).reduce(parametros.grepv(Regexp)){|acum,coso|coso+acum}
  end

  def self.aplicarAspectos(parametros,&closure)
    parametros.each do |arg|
      (arg.instance_eval &closure)
    end
  end
end


module Aspectable

  def self.define_known_method_to_object(method_name,related_class)
    define_method(method_name){|*parameters,&block| related_class.new(*parameters,&block)}
  end

  def toAspectable
    self
  end

  def where(*conditions)
    puts metodos.select{|metodo|conditions.all?{|condicion|condicion.esCumplida(metodo,self)}}.to_s
  end

  define_method(:define){|method,&closure|singleton_class.send("define_"+modifier+"method",method,&closure)}
  define_method(:metodos){send(modifier+"methods") + send("private_"+modifier+"methods")}
  define_method(:metodo){|method|send(modifier+"method",method)}
  define_method(:espublico?)do
  |method|
    metodo(method)
    send("public_"+modifier+"methods").include?(method)
  end
  define_method(:esprivado?)do
  |method|
    metodo(method)
    send("private_"+modifier+"methods").include?(method)
  end

end

module ConcreteAspectable
  include Aspectable

def modifier
  ""
end

end

module AbstractAspectable include Aspectable

def modifier
  "instance_"
end

end


load 'ClasesExtendidas'
load 'Condiciones'
load 'MethodReflector'