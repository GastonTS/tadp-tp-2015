load 'Condiciones'
load 'ClasesExtendidas'

class Aspects
  def self.on(*args,&closure)

    aspectables = encontrarAspectables(*args)

    throw(ArgumentError,"Origen Vacio") if aspectables.size==0

    aplicarAspectos(aspectables,&closure)

  end

  def self.encontrarAspectables(*parametros)
    parametros.grep(Regexp).map(&:toAspectable).reduce(parametros.grepv(Regexp)){|acum,coso|coso+acum}
  end

  def self.aplicarAspectos(parametros,&closure)
    parametros.each do |arg|
      (arg.instance_eval &closure)
    end
  end
end


module Aspectable

 $condiciones.keys.map { |unMetodo|   define_method(unMetodo){|*args|[unMetodo,*args]}}


  def toAspectable
    self
  end

  def where(*constructoresCondiciones)
    condiciones = constructoresCondiciones.map{|constructor,*args| CreadorDeCondiciones.send(constructor,*args)}
    puts metodos.select{|metodo|condiciones.all?{|condicion|condicion.esCumplida(metodo,self)}}.to_s
  end



end

module ConcreteAspectable include Aspectable

def define(metodo,&closure)
  define_singleton_method(metodo,&closure)
end

def metodos
  methods + private_methods
end

def espublico?(unMetodo)
  self.method(unMetodo) #Nomas para garantizar que el metodo exista, si no existe explota aca
  self.public_methods.include?(unMetodo)
end

def esprivado?(unMetodo)
  self.method(unMetodo) #Nomas para garantizar que el metodo exista, si no existe explota aca
  self.private_methods.include?(unMetodo)
end

end

module AbstractAspectable include Aspectable

def define(metodo,&closure)
  define_method(metodo,&closure)
end

def metodos
  instance_methods + private_instance_methods
end

def espublico?(unMetodo)
  self.instance_method(unMetodo) #Nomas para garantizar que el metodo exista, si no existe explota aca
  self.public_instance_methods.include?(unMetodo)
end

def esprivado?(unMetodo)
  self.instance_method(unMetodo) #Nomas para garantizar que el metodo exista, si no existe explota aca
  self.private_instance_methods.include?(unMetodo)
end


end


