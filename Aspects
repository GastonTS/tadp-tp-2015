load 'Condiciones'
load 'MethodReflector'
load 'MethodReflector'

class Aspects
  def self.on(*args,&closure)

    aspectables = encontrarAspectables(*args)

    throw(ArgumentError,"Origen Vacio") if aspectables.size==0

    aplicarAspectos(aspectables,&closure)

  end

  def self.encontrarAspectables(*parametros)
    parametros.grep(Regexp).map(&:toAspectable).reduce(parametros.grepv(Regexp)){|acum,coso|coso+acum}
  end

  def self.aplicarAspectos(parametros,&closure)
    parametros.each do |arg|
      (arg.instance_eval &closure)
    end
  end
end


module Aspectable
  extend MethodReflector
  define_known_method_to_object_block_method = proc {|method_name,related_class| define_method(method_name){|*parameters,&block| related_class.new(*parameters,&block)}}
  $tiposParametros.each{|symbol,condition| Aspectable.send(:define_method,symbol){condition}}
  $condiciones.each do |condition,cond_class| define_known_method_to_object_block_method.call(condition,cond_class) end

  def toAspectable
    self
  end

  def where(*conditions)
    puts metodos.select{|metodo|conditions.all?{|condicion|condicion.esCumplida(metodo,self)}}.to_s
  end

end

module ConcreteAspectable
  include Aspectable

def define(metodo,&closure)
  define_singleton_method(metodo,&closure)
end

def metodos
  methods + private_methods
end

def metodo(unMetodo)
  method(unMetodo)
end

def espublico?(unMetodo)
  self.method(unMetodo) #Nomas para garantizar que el metodo exista, si no existe explota aca
  self.public_methods.include?(unMetodo)
end

def esprivado?(unMetodo)
  self.method(unMetodo) #Nomas para garantizar que el metodo exista, si no existe explota aca
  self.private_methods.include?(unMetodo)
end

end

module AbstractAspectable include Aspectable

def define(metodo,&closure)
  define_method(metodo,&closure)
end

def metodos
  instance_methods + private_instance_methods
end

def metodo(unMetodo)
  instance_method(unMetodo)
end

def espublico?(unMetodo)
  self.instance_method(unMetodo) #Nomas para garantizar que el metodo exista, si no existe explota aca
  self.public_instance_methods.include?(unMetodo)
end

def esprivado?(unMetodo)
  self.instance_method(unMetodo) #Nomas para garantizar que el metodo exista, si no existe explota aca
  self.private_instance_methods.include?(unMetodo)
end


end


load 'ClasesExtendidas'