class Condicion
  def esCumplida(unMetodo)
  end
end

class Visibilidad < Condicion
  def esCumplida(unMetodo,poseedorDelMetodo)
    poseedorDelMetodo.esPublico?(unMetodo) == debeSerPublico
  end
end



class EsPrivado < Visibilidad
  def debeSerPublico
    false
  end
end

class EsPublico < Visibilidad
  def debeSerPublico
    true
  end
end

class Selector < Condicion

  def initialize(unaExp)
    @regexp=unaExp
  end
  def esCumplida(unMetodo,poseedorDelMetodo)
    @regexp.match(unMetodo)
  end
end

class CreadorDeCondiciones
  def initialize
    @creadorDeCondiciones=Object.new
  end
  def self.condicionCreable(nombreMetodo,clase)
    define_singleton_method(nombreMetodo){|*parametrosNew|clase.new(*parametrosNew)}
  end
end

$condiciones = {:nombre => Selector, :is_private => EsPrivado, :is_public => EsPublico}

$condiciones.each do
|metodo,clase| CreadorDeCondiciones.send(:condicionCreable,metodo,clase)
end





class Aspects
  def self.on(*args,&closure)

    aspectables = encontrarAspectables(*args)

    throw(ArgumentError,"Origen Vacio") if aspectables.size==0

    aplicarAspectos(aspectables,&closure)

  end

  def self.encontrarAspectables(*parametros)
    parametros.grep(Regexp).map(&:toAspectable).reduce(parametros.grepv(Regexp)){|acum,coso|coso+acum}
  end

  def self.aplicarAspectos(parametros,&closure)
    parametros.each do |arg|
      (arg.instance_eval &closure)
    end
  end
end


module Aspectable

 $condiciones.keys.map { |unMetodo|   define_method(unMetodo){|*args|[unMetodo,*args]}}


  def toAspectable
    self
  end

  def where(*constructoresCondiciones)
    condiciones = constructoresCondiciones.map{|constructor,*args| CreadorDeCondiciones.send(constructor,*args)}
    puts metodos.select{|metodo|condiciones.all?{|condicion|condicion.esCumplida(metodo,self)}}.to_s
  end



end

module ConcreteAspectable include Aspectable

def define(metodo,&closure)
  define_singleton_method(metodo,&closure)
end

def metodos
  methods + private_methods
end

def esPublico?(unMetodo)
  self.method(unMetodo) #Nomas para garantizar que el metodo exista, si no existe explota aca
  self.public_methods.include?(unMetodo)
end

end

module AbstractAspectable include Aspectable

def define(metodo,&closure)
  define_method(metodo,&closure)
end

def metodos
  instance_methods + private_instance_methods
end

def esPublico?(unMetodo)
  self.instance_method(unMetodo) #Nomas para garantizar que el metodo exista, si no existe explota aca
  self.public_instance_methods.include?(unMetodo)
end

end

class Array
  def grepv(parametroMagico)
    self-self.grep(parametroMagico)
  end
end

class Regexp
  def toAspectable
    (Object.clases+Object.modulos).uniq
                                  .select{|const|const.to_s.match(self)}
  end
end

class Object
  include ConcreteAspectable
  def self.clases
    constantesQueSon(Class)
  end
  def self.modulos
    constantesQueSon(Module)
  end
  def self.constantesQueSon(unTipo)
    constants .map(&Object.method(:const_get))
        .grep(unTipo)
  end

end

class Class
  include AbstractAspectable
end

class Module
  include AbstractAspectable
end



